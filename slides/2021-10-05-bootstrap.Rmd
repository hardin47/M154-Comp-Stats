---
title: "Bootstrapping"
author: "Jo Hardin"
date: "October 3 & 5, 2021"
output:
  xaringan::moon_reader:
    nature:
      highlightlines: true
      titleSlideClass: ["right", "top", "my-title"]
---

```{r include=FALSE}
library(tidyverse)
require(mosaic)
require(boot)
require(ggthemes)
require(knitr)
opts_chunk$set(
  message=FALSE,
  warning=FALSE,
  size='small',
  cache=TRUE,
  tidy=FALSE
  )
require(lubridate)
require(sysfonts)
options(width=65, digits=3)
```


## Why bootstrap?

Motivation:  to estimate the variability of a statistic (*not* dependent on $H_0$ being true).

---

## Example
- Hesketh and Everitt (2000) report on a study by Caplehorn and Bell (1991) that investigated the times that heroin addicts remained in a clinic for methadone maintenance treatment.  

- The data include the amount of time that the subjects stayed in the facility until treatment was terminated (column 4). 

- For about 37% of the subjects, the study ended while they were still the in clinic (status=0).  

- Their survival time has been truncated.  For this reason we might not want to estimate the mean survival time, but rather some other measure of typical survival time.  Below we explore using the median as well as the 25% trimmed mean.   (From ISCAM Chance & Rossman, Investigation 4.5.3)

---

## Reading in the data
```{r}
heroin <- readr::read_table2("http://www.rossmanchance.com/iscam2/data/heroin.txt")
names(heroin)
head(heroin)
```

---

## Observed Test Statistic(s)
```{r}
obs.stat<-heroin %>% 
  summarize(medtime = median(times)) %>% pull()
obs.stat2<-heroin %>% 
  summarize(tmeantime = mean(times, trim=0.25)) %>% pull()
obs.stat
obs.stat2
```

---


## Bootstrapped data!
```{r}
set.seed(4747)
heroin.rs<-heroin %>% sample_frac(size=1, replace=TRUE)

heroin.rs %>% 
  summarize(medtime = median(times)) %>% pull()
heroin.rs %>% 
  summarize(tmeantime = mean(times, trim=0.25)) %>% pull()
```

---


##  Need to bootstrap a lot of times...
Bootstrapping with `map`ping.  [The package `boot` will do it for you!]

```{r echo=FALSE}
test.stat<-c()
test.stat2<-c()
sd.test.stat<-c()
sd.test.stat2<-c()

reps1 <- 1000
reps2 <- 200
set.seed(4747)
```

```{r}
for(i in 1:reps1){ 
	heroin.rs<-heroin %>% sample_frac(size=1, replace=TRUE)
	test.stat<-c(test.stat,heroin.rs %>% 
	               summarize(medtime = median(times)) %>% pull())
	test.stat2<-c(test.stat2,heroin.rs %>% 
	                summarize(tmeantime = mean(times, trim=0.25)) %>% pull())

	test.stat.rs<-c()
	test.stat2.rs<-c()

	for(j in 1:reps2){
	heroin.rsrs<-heroin.rs %>% sample_frac(size=1, replace=TRUE)
	test.stat.rs<-c(test.stat.rs,
	                heroin.rsrs %>% 
	                  summarize(medtime = median(times)) %>% pull())
	test.stat2.rs<-c(test.stat2.rs,
	                 heroin.rsrs %>% 
	                   summarize(tmeantime = mean(times, trim=0.25)) %>% pull())
	}
	sd.test.stat<-c(sd.test.stat,sd(test.stat.rs))
	sd.test.stat2<-c(sd.test.stat2,sd(test.stat2.rs))
}

```


---



## What do the **data** distributions look like?

```{r echo=FALSE, fig.width=4}
ggplot(heroin, aes(x=times)) + 
  geom_histogram(bins=30) + 
  ggtitle("original sample")
ggplot(heroin.rs, aes(x=times)) + 
  geom_histogram(bins=30) + 
  ggtitle("one random sample")
```


---

## What do the **sampling** distributions look like?

Both the median and the trimmed mean are symmetric and bell-shaped.  

.pull-left[
```{r echo=FALSE, fig.width=4, fig.height=6}
bs.stats <- data.frame(test.stat, test.stat2)
ggplot(bs.stats, aes(x=test.stat)) + 
  geom_histogram(bins=20) + 
  ggtitle("dist of median") +  
  xlab(paste("mean=",round(mean(test.stat),2),";
             SE=", round(sd(test.stat),2)))
```
]

.pull-right[
```{r echo=FALSE, fig.width=4, fig.height=6}
ggplot(bs.stats, aes(x=test.stat2)) + 
  geom_histogram(bins=20) + 
  ggtitle("dist of trimmed mean") +  
  xlab(paste("mean=",round(mean(test.stat),2),";
             SE=", round(sd(test.stat),2)))

```
]
---

## OR using the built in functions
```{r}
sampletmean <- function(x,d,trimperc){
  return(mean(x[d], trim=trimperc))
}
set.seed(4747)
bs.tmean.resamps <- boot(heroin$times,
                         sampletmean, reps1, trimperc=.25)
```

---

## What does the boot output look like?
```{r}
# bs.tmean.resamps <- boot(heroin$times,sampletmean, reps1, trimperc=.25)
str(bs.tmean.resamps)
```

---

## What does the boot output look like?


```{r}
samplemed <- function(x,d){
  return(median(x[d]))
}
set.seed(4747)
bs.med.resamps <- boot(heroin$times,
                       samplemed, reps1)
bs.med.resamps
```

---

## SE of median

Whew!  They are very close (one using for loops, one using the boot function).

```{r}
sd(test.stat)  # SE of median

bs.med.resamps
```

---

## SE of trimmed mean

Whew!  They are very close (one using for loops, one using the boot function).

```{r}
sd(test.stat2)  # SE of trimmed mean

bs.tmean.resamps
```

---

## 95% normal CI with BS SE

.pull-left[
Without built in functions
```{r}
obs.stat + 
  qnorm(c(.025,.975))*
  sd(test.stat)
obs.stat2 + 
  qnorm(c(.025,.975))*
  sd(test.stat2)
```
]

.pull-right[
With built in functions
```{r}
se.bs <- sd(bs.med.resamps$t)
se.bs2 <- sd(bs.tmean.resamps$t)

obs.stat + 
  qnorm(c(0.025,.975))*
  se.bs

obs.stat2 + 
  qnorm(c(0.025,.975))*
  se.bs2 
```
]

---


## 95% Percentile CI

.pull-left[
Without built in functions
```{r}
quantile(test.stat, c(.025, .975))
quantile(test.stat2, c(.025, .975))
```
]

.pull-right[
With built in functions
```{r}
quantile(bs.med.resamps$t, c(.025, .975))
quantile(bs.tmean.resamps$t, c(.025, .975))
```
]
---

### With built in functions more directly
```{r}
boot.ci(bs.med.resamps, type="perc")
boot.ci(bs.tmean.resamps, type="perc")
```

---

## 95% Bootstrap-t CI

### Without built in functions

Note that the t-value is needed (which requires a different SE for each bootstrap sample).

```{r}
t.hat<-(test.stat - obs.stat)/sd.test.stat
t.hat2<-(test.stat2 - obs.stat2)/sd.test.stat2

t.hat.95 = quantile(t.hat, c(.025,.975))
t.hat2.95 = quantile(t.hat2, c(.025,.975))

obs.stat + t.hat.95*sd(test.stat)

obs.stat2 + t.hat2.95*sd(test.stat2) 
```

---

### With built in functions

Trimmed mean:
```{r}
sampletmean2 <- function(x, d, R2, trimperc) {
   boot.samp = x[d]  # boostrapped sample
   m.bs = mean(boot.samp, trim=trimperc)  # bootstrapped mean
   v.bs = var(boot(boot.samp, sampletmean, R2, trim=trimperc)$t)
   return(c(m.bs, v.bs))  
   # boot expects the statistic to be the 1st and the var to be the 2nd
}
set.seed(4747)
bs.tmean.reresamps <- boot(heroin$times, sampletmean2, R=reps1, R2=reps2, trimperc=.25)
```

---

### With built in functions

Median:
```{r}
samplemed2 <- function(x, d, R2) {
   boot.samp = x[d]  # boostrapped sample
   m.bs = median(boot.samp)  # bootstrapped mean
   v.bs = var(boot(boot.samp, samplemed, R2)$t)
   return(c(m.bs, v.bs))  
   # boot expects the statistic to be the 1st and the var to be the 2nd
}
set.seed(4747)
bs.med.reresamps <- boot(heroin$times, samplemed2, R=reps1, R2=reps2)
```

---
The confidence intervals (BS-t intervals, called "studentized"):
```{r}
boot.ci(bs.med.reresamps, type="stud")
boot.ci(bs.tmean.reresamps, type="stud")
```

---

## 95% BCa interval (not responsible for BCa)

### With built in functions
```{r eval=FALSE}
boot.ci(bs.med.reresamps, type="bca")
boot.ci(bs.tmean.reresamps, type="bca")
```


### Without built in functions
```{r eval=FALSE}
test.stat.jk<-c()
test.stat2.jk<-c()

set.seed(4747)
for(i in 1:length(heroin$times)){

	test.stat.jk<-c(test.stat.jk,median(heroin$times[-i]))
	 test.stat2.jk<-c(test.stat2.jk,mean(heroin$times[-i],trim=.25))
}

zo.hat<-qnorm(sum(test.stat<obs.stat)/reps1,0,1)
a.hat<- sum((mean(test.stat.jk) - test.stat.jk)^3)/
                 (6*(sum((mean(test.stat.jk)-test.stat.jk)^2)^1.5))

zo.hat2<- qnorm(sum(test.stat2< obs.stat2)/reps1,0,1)
a.hat2<- sum((mean(test.stat2.jk) - test.stat2.jk)^3)/
                 (6*(sum((mean(test.stat2.jk)-test.stat2.jk)^2)^1.5))

alpha1.bca<-pnorm(zo.hat + (zo.hat + qnorm(.975))/(1 - a.hat*(zo.hat + qnorm(.975))))
alpha2.bca<-pnorm(zo.hat + (zo.hat + qnorm(.025))/(1 - a.hat*(zo.hat + qnorm(.025))))


alpha1.bca2<-pnorm(zo.hat2 + (zo.hat2 + qnorm(.975))/(1 - a.hat2*(zo.hat2 + qnorm(.975))))
alpha2.bca2<-pnorm(zo.hat2 + (zo.hat2 + qnorm(.025))/(1 - a.hat2*(zo.hat2 + qnorm(.025))))


c(sort(test.stat)[ceiling(reps1*alpha2.bca)],sort(test.stat)[ceiling(reps1*alpha1.bca)])
c(sort(test.stat2)[ceiling(reps1*alpha2.bca2)],sort(test.stat2)[ceiling(reps1*alpha1.bca2)])
```

---

## Comparison of intervals

The first three columns  correspond to the CIs for the true median of the survival times.  The second three columns correspond to the CIs for the true trimmed mean of the survival times.


CI | lower | observed | upper | lower | observed | upper
--- | ----- | ----- | ----- | ----- | ------ | -------- | 
Percentile | 321.00 | 367.50| 452.00 | 339.38 | 378.30 | 423.46
CI w BS SE | 306.33 | 367.50|428.67 | 335.21 | 378.30 | 421.39
BS-t | 294.98 | 367.50|418.00 | 334.28 | 378.30 | 418.09
BCa | 317.00 | 367.50|444.00 | 338.29 | 378.30 | 422.43







