<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Bootstrapping</title>
    <meta charset="utf-8" />
    <meta name="author" content="Jo Hardin" />
    <script src="2021-10-05-bootstrap_files/header-attrs-2.11.1/header-attrs.js"></script>
    <link href="2021-10-05-bootstrap_files/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="2021-10-05-bootstrap_files/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: right, top, my-title, title-slide

# Bootstrapping
### Jo Hardin
### October 3 &amp; 5, 2021

---





## Why bootstrap?

Motivation:  to estimate the variability of a statistic (*not* dependent on `\(H_0\)` being true).

---

## Example
- Hesketh and Everitt (2000) report on a study by Caplehorn and Bell (1991) that investigated the times that heroin addicts remained in a clinic for methadone maintenance treatment.  

- The data include the amount of time that the subjects stayed in the facility until treatment was terminated (column 4). 

- For about 37% of the subjects, the study ended while they were still the in clinic (status=0).  

- Their survival time has been truncated.  For this reason we might not want to estimate the mean survival time, but rather some other measure of typical survival time.  Below we explore using the median as well as the 25% trimmed mean.   (From ISCAM Chance &amp; Rossman, Investigation 4.5.3)

---

## Reading in the data

```r
heroin &lt;- readr::read_table2("http://www.rossmanchance.com/iscam2/data/heroin.txt")
names(heroin)
```

```
## [1] "id"     "clinic" "status" "times"  "prison" "dose"
```

```r
head(heroin)
```

```
## # A tibble: 6 Ã— 6
##      id clinic status times prison  dose
##   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;
## 1     1      1      1   428      0    50
## 2     2      1      1   275      1    55
## 3     3      1      1   262      0    55
## 4     4      1      1   183      0    30
## 5     5      1      1   259      1    65
## 6     6      1      1   714      0    55
```

---

## Observed Test Statistic(s)

```r
obs.stat&lt;-heroin %&gt;% 
  summarize(medtime = median(times)) %&gt;% pull()
obs.stat2&lt;-heroin %&gt;% 
  summarize(tmeantime = mean(times, trim=0.25)) %&gt;% pull()
obs.stat
```

```
## [1] 368
```

```r
obs.stat2
```

```
## [1] 378
```

---


## Bootstrapped data!

```r
set.seed(4747)
heroin.rs&lt;-heroin %&gt;% sample_frac(size=1, replace=TRUE)

heroin.rs %&gt;% 
  summarize(medtime = median(times)) %&gt;% pull()
```

```
## [1] 368
```

```r
heroin.rs %&gt;% 
  summarize(tmeantime = mean(times, trim=0.25)) %&gt;% pull()
```

```
## [1] 372
```

---


##  Need to bootstrap a lot of times...
Bootstrapping with `map`ping.  [The package `boot` will do it for you!]




```r
for(i in 1:reps1){ 
	heroin.rs&lt;-heroin %&gt;% sample_frac(size=1, replace=TRUE)
	test.stat&lt;-c(test.stat,heroin.rs %&gt;% 
	               summarize(medtime = median(times)) %&gt;% pull())
	test.stat2&lt;-c(test.stat2,heroin.rs %&gt;% 
	                summarize(tmeantime = mean(times, trim=0.25)) %&gt;% pull())

	test.stat.rs&lt;-c()
	test.stat2.rs&lt;-c()

	for(j in 1:reps2){
	heroin.rsrs&lt;-heroin.rs %&gt;% sample_frac(size=1, replace=TRUE)
	test.stat.rs&lt;-c(test.stat.rs,
	                heroin.rsrs %&gt;% 
	                  summarize(medtime = median(times)) %&gt;% pull())
	test.stat2.rs&lt;-c(test.stat2.rs,
	                 heroin.rsrs %&gt;% 
	                   summarize(tmeantime = mean(times, trim=0.25)) %&gt;% pull())
	}
	sd.test.stat&lt;-c(sd.test.stat,sd(test.stat.rs))
	sd.test.stat2&lt;-c(sd.test.stat2,sd(test.stat2.rs))
}
```


---



## What do the **data** distributions look like?

![](2021-10-05-bootstrap_files/figure-html/unnamed-chunk-7-1.png)&lt;!-- --&gt;![](2021-10-05-bootstrap_files/figure-html/unnamed-chunk-7-2.png)&lt;!-- --&gt;


---

## What do the **sampling** distributions look like?

Both the median and the trimmed mean are symmetric and bell-shaped.  

.pull-left[
![](2021-10-05-bootstrap_files/figure-html/unnamed-chunk-8-1.png)&lt;!-- --&gt;
]

.pull-right[
![](2021-10-05-bootstrap_files/figure-html/unnamed-chunk-9-1.png)&lt;!-- --&gt;
]
---

## OR using the built in functions

```r
sampletmean &lt;- function(x,d,trimperc){
  return(mean(x[d], trim=trimperc))
}
set.seed(4747)
bs.tmean.resamps &lt;- boot(heroin$times,
                         sampletmean, reps1, trimperc=.25)
```

---

## What does the boot output look like?

```r
# bs.tmean.resamps &lt;- boot(heroin$times,sampletmean, reps1, trimperc=.25)
str(bs.tmean.resamps)
```

```
## List of 11
##  $ t0       : num 378
##  $ t        : num [1:1000, 1] 364 377 372 392 349 ...
##  $ R        : num 1000
##  $ data     : num [1:238] 428 275 262 183 259 714 438 796 892 393 ...
##  $ seed     : int [1:626] 10403 624 -1645349161 -2081516244 1489809469 823736794 -755145325 950390200 -1779428263 1453445190 ...
##  $ statistic:function (x, d, trimperc)  
##   ..- attr(*, "srcref")= 'srcref' int [1:8] 1 16 3 1 16 1 1 3
##   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' &lt;environment: 0x7f7eba511c40&gt; 
##  $ sim      : chr "ordinary"
##  $ call     : language boot(data = heroin$times, statistic = sampletmean, R = reps1,      trimperc = 0.25)
##  $ stype    : chr "i"
##  $ strata   : num [1:238] 1 1 1 1 1 1 1 1 1 1 ...
##  $ weights  : num [1:238] 0.0042 0.0042 0.0042 0.0042 0.0042 ...
##  - attr(*, "class")= chr "boot"
##  - attr(*, "boot_type")= chr "boot"
```

---

## What does the boot output look like?



```r
samplemed &lt;- function(x,d){
  return(median(x[d]))
}
set.seed(4747)
bs.med.resamps &lt;- boot(heroin$times,
                       samplemed, reps1)
bs.med.resamps
```

```
## 
## ORDINARY NONPARAMETRIC BOOTSTRAP
## 
## 
## Call:
## boot(data = heroin$times, statistic = samplemed, R = reps1)
## 
## 
## Bootstrap Statistics :
##     original  bias    std. error
## t1*      368    7.64        32.2
```

---

## SE of median

Whew!  They are very close (one using for loops, one using the boot function).


```r
sd(test.stat)  # SE of median
```

```
## [1] 33
```

```r
bs.med.resamps
```

```
## 
## ORDINARY NONPARAMETRIC BOOTSTRAP
## 
## 
## Call:
## boot(data = heroin$times, statistic = samplemed, R = reps1)
## 
## 
## Bootstrap Statistics :
##     original  bias    std. error
## t1*      368    7.64        32.2
```

---

## SE of trimmed mean

Whew!  They are very close (one using for loops, one using the boot function).


```r
sd(test.stat2)  # SE of trimmed mean
```

```
## [1] 23.2
```

```r
bs.tmean.resamps
```

```
## 
## ORDINARY NONPARAMETRIC BOOTSTRAP
## 
## 
## Call:
## boot(data = heroin$times, statistic = sampletmean, R = reps1, 
##     trimperc = 0.25)
## 
## 
## Bootstrap Statistics :
##     original  bias    std. error
## t1*      378   0.635        22.3
```

---

## 95% normal CI with BS SE

.pull-left[
Without built in functions

```r
obs.stat + 
  qnorm(c(.025,.975))*
  sd(test.stat)
```

```
## [1] 303 432
```

```r
obs.stat2 + 
  qnorm(c(.025,.975))*
  sd(test.stat2)
```

```
## [1] 333 424
```
]

.pull-right[
With built in functions

```r
se.bs &lt;- sd(bs.med.resamps$t)
se.bs2 &lt;- sd(bs.tmean.resamps$t)

obs.stat + 
  qnorm(c(0.025,.975))*
  se.bs
```

```
## [1] 304 431
```

```r
obs.stat2 + 
  qnorm(c(0.025,.975))*
  se.bs2 
```

```
## [1] 335 422
```
]

---


## 95% Percentile CI

.pull-left[
Without built in functions

```r
quantile(test.stat, c(.025, .975))
```

```
##  2.5% 97.5% 
##   320   452
```

```r
quantile(test.stat2, c(.025, .975))
```

```
##  2.5% 97.5% 
##   334   425
```
]

.pull-right[
With built in functions

```r
quantile(bs.med.resamps$t, c(.025, .975))
```

```
##  2.5% 97.5% 
##   320   452
```

```r
quantile(bs.tmean.resamps$t, c(.025, .975))
```

```
##  2.5% 97.5% 
##   334   423
```
]
---

### With built in functions more directly

```r
boot.ci(bs.med.resamps, type="perc")
```

```
## BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS
## Based on 1000 bootstrap replicates
## 
## CALL : 
## boot.ci(boot.out = bs.med.resamps, type = "perc")
## 
## Intervals : 
## Level     Percentile     
## 95%   (320, 452 )  
## Calculations and Intervals on Original Scale
```

```r
boot.ci(bs.tmean.resamps, type="perc")
```

```
## BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS
## Based on 1000 bootstrap replicates
## 
## CALL : 
## boot.ci(boot.out = bs.tmean.resamps, type = "perc")
## 
## Intervals : 
## Level     Percentile     
## 95%   (334, 423 )  
## Calculations and Intervals on Original Scale
```

---

## 95% Bootstrap-t CI

### Without built in functions

Note that the t-value is needed (which requires a different SE for each bootstrap sample).


```r
t.hat&lt;-(test.stat - obs.stat)/sd.test.stat
t.hat2&lt;-(test.stat2 - obs.stat2)/sd.test.stat2

t.hat.95 = quantile(t.hat, c(.025,.975))
t.hat2.95 = quantile(t.hat2, c(.025,.975))

obs.stat + t.hat.95*sd(test.stat)
```

```
##  2.5% 97.5% 
##   310   443
```

```r
obs.stat2 + t.hat2.95*sd(test.stat2) 
```

```
##  2.5% 97.5% 
##   332   425
```

---

### With built in functions

Trimmed mean:

```r
sampletmean2 &lt;- function(x, d, R2, trimperc) {
   boot.samp = x[d]  # boostrapped sample
   m.bs = mean(boot.samp, trim=trimperc)  # bootstrapped mean
   v.bs = var(boot(boot.samp, sampletmean, R2, trim=trimperc)$t)
   return(c(m.bs, v.bs))  
   # boot expects the statistic to be the 1st and the var to be the 2nd
}
set.seed(4747)
bs.tmean.reresamps &lt;- boot(heroin$times, sampletmean2, R=reps1, R2=reps2, trimperc=.25)
```

---

### With built in functions

Median:

```r
samplemed2 &lt;- function(x, d, R2) {
   boot.samp = x[d]  # boostrapped sample
   m.bs = median(boot.samp)  # bootstrapped mean
   v.bs = var(boot(boot.samp, samplemed, R2)$t)
   return(c(m.bs, v.bs))  
   # boot expects the statistic to be the 1st and the var to be the 2nd
}
set.seed(4747)
bs.med.reresamps &lt;- boot(heroin$times, samplemed2, R=reps1, R2=reps2)
```

---
The confidence intervals (BS-t intervals, called "studentized"):

```r
boot.ci(bs.med.reresamps, type="stud")
```

```
## BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS
## Based on 1000 bootstrap replicates
## 
## CALL : 
## boot.ci(boot.out = bs.med.reresamps, type = "stud")
## 
## Intervals : 
## Level    Studentized     
## 95%   (295, 420 )  
## Calculations and Intervals on Original Scale
```

```r
boot.ci(bs.tmean.reresamps, type="stud")
```

```
## BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS
## Based on 1000 bootstrap replicates
## 
## CALL : 
## boot.ci(boot.out = bs.tmean.reresamps, type = "stud")
## 
## Intervals : 
## Level    Studentized     
## 95%   (335, 422 )  
## Calculations and Intervals on Original Scale
```

---

## 95% BCa interval (not responsible for BCa)

### With built in functions

```r
boot.ci(bs.med.reresamps, type="bca")
boot.ci(bs.tmean.reresamps, type="bca")
```


### Without built in functions

```r
test.stat.jk&lt;-c()
test.stat2.jk&lt;-c()

set.seed(4747)
for(i in 1:length(heroin$times)){

	test.stat.jk&lt;-c(test.stat.jk,median(heroin$times[-i]))
	 test.stat2.jk&lt;-c(test.stat2.jk,mean(heroin$times[-i],trim=.25))
}

zo.hat&lt;-qnorm(sum(test.stat&lt;obs.stat)/reps1,0,1)
a.hat&lt;- sum((mean(test.stat.jk) - test.stat.jk)^3)/
                 (6*(sum((mean(test.stat.jk)-test.stat.jk)^2)^1.5))

zo.hat2&lt;- qnorm(sum(test.stat2&lt; obs.stat2)/reps1,0,1)
a.hat2&lt;- sum((mean(test.stat2.jk) - test.stat2.jk)^3)/
                 (6*(sum((mean(test.stat2.jk)-test.stat2.jk)^2)^1.5))

alpha1.bca&lt;-pnorm(zo.hat + (zo.hat + qnorm(.975))/(1 - a.hat*(zo.hat + qnorm(.975))))
alpha2.bca&lt;-pnorm(zo.hat + (zo.hat + qnorm(.025))/(1 - a.hat*(zo.hat + qnorm(.025))))


alpha1.bca2&lt;-pnorm(zo.hat2 + (zo.hat2 + qnorm(.975))/(1 - a.hat2*(zo.hat2 + qnorm(.975))))
alpha2.bca2&lt;-pnorm(zo.hat2 + (zo.hat2 + qnorm(.025))/(1 - a.hat2*(zo.hat2 + qnorm(.025))))


c(sort(test.stat)[ceiling(reps1*alpha2.bca)],sort(test.stat)[ceiling(reps1*alpha1.bca)])
c(sort(test.stat2)[ceiling(reps1*alpha2.bca2)],sort(test.stat2)[ceiling(reps1*alpha1.bca2)])
```

---

## Comparison of intervals

The first three columns  correspond to the CIs for the true median of the survival times.  The second three columns correspond to the CIs for the true trimmed mean of the survival times.


CI | lower | observed | upper | lower | observed | upper
--- | ----- | ----- | ----- | ----- | ------ | -------- | 
Percentile | 321.00 | 367.50| 452.00 | 339.38 | 378.30 | 423.46
CI w BS SE | 306.33 | 367.50|428.67 | 335.21 | 378.30 | 421.39
BS-t | 294.98 | 367.50|418.00 | 334.28 | 378.30 | 418.09
BCa | 317.00 | 367.50|444.00 | 338.29 | 378.30 | 422.43







    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightlines": true
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
